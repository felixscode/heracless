use crate::tree::{Node, Structure, Tree, to_pascal_case, to_snake_case};
use std::collections::HashSet;

/// Generate the type annotation for a node
fn generate_type_annotation(node: &Node) -> String {
    match node {
        Node::Leaf(leaf) => leaf.type_name.clone(),
        Node::Structure(structure) => {
            match structure.type_name.as_str() {
                "Mapping" => to_pascal_case(&structure.name),
                "Vec" => {
                    if let Some(first_child) = structure.children.first() {
                        format!("Vec<{}>", generate_type_annotation(first_child))
                    } else {
                        "Vec<Value>".to_string()
                    }
                }
                _ => structure.type_name.clone(),
            }
        }
    }
}

/// Generate a field definition for a struct
fn generate_field(node: &Node) -> String {
    let field_name = to_snake_case(node.name());
    let type_annotation = generate_type_annotation(node);
    format!("    pub {}: {},", field_name, type_annotation)
}

/// Generate a struct definition from a Structure
fn generate_struct(structure: &Structure, frozen: bool) -> String {
    let struct_name = to_pascal_case(&structure.name);
    let mut result = String::new();

    // Add derives
    result.push_str("#[derive(Debug, Clone, PartialEq");
    if !frozen {
        result.push_str(")]\n");
    } else {
        result.push_str(")]\n");
    }
    result.push_str("#[derive(serde::Serialize, serde::Deserialize)]\n");

    // Struct definition
    result.push_str(&format!("pub struct {} {{\n", struct_name));

    // Fields
    for child in &structure.children {
        result.push_str(&generate_field(child));
        result.push('\n');
    }

    result.push_str("}\n");
    result
}

/// Generate code for an entire tree
pub fn generate_code(tree: &Tree, frozen: bool) -> String {
    let mut result = String::new();

    // Header with imports
    result.push_str("// Auto-generated by Heracless\n");
    result.push_str("// DO NOT EDIT THIS FILE MANUALLY\n\n");
    result.push_str("use serde::{Deserialize, Serialize};\n");
    result.push_str("use serde_yaml::Value;\n\n");

    // Collect all structures that need to be generated
    let mut structures = Vec::new();
    for child in &tree.children {
        match child {
            Node::Structure(structure) if structure.type_name == "Mapping" => {
                structures.push(structure);
                collect_nested_structures(structure, &mut structures);
            }
            _ => {}
        }
    }

    // Remove duplicates (by name)
    let mut seen = HashSet::new();
    let mut unique_structures = Vec::new();
    for structure in structures.iter().rev() {
        let name = to_pascal_case(&structure.name);
        if !seen.contains(&name) {
            seen.insert(name);
            unique_structures.push(*structure);
        }
    }
    unique_structures.reverse();

    // Generate struct definitions
    for structure in &unique_structures {
        result.push_str(&generate_struct(structure, frozen));
        result.push('\n');
    }

    // Generate the root Config type
    result.push_str("#[derive(Debug, Clone, PartialEq)]\n");
    result.push_str("#[derive(serde::Serialize, serde::Deserialize)]\n");
    result.push_str("pub struct Config {\n");
    for child in &tree.children {
        result.push_str(&generate_field(child));
        result.push('\n');
    }
    result.push_str("}\n\n");

    // Generate load function
    result.push_str("impl Config {\n");
    result.push_str("    pub fn load(path: &std::path::Path) -> Result<Self, Box<dyn std::error::Error>> {\n");
    result.push_str("        let content = std::fs::read_to_string(path)?;\n");
    result.push_str("        let config: Config = serde_yaml::from_str(&content)?;\n");
    result.push_str("        Ok(config)\n");
    result.push_str("    }\n\n");
    result.push_str("    pub fn to_json(&self) -> Result<String, Box<dyn std::error::Error>> {\n");
    result.push_str("        Ok(serde_json::to_string_pretty(self)?)\n");
    result.push_str("    }\n");
    result.push_str("}\n");

    result
}

/// Recursively collect all nested structures
fn collect_nested_structures<'a>(structure: &'a Structure, result: &mut Vec<&'a Structure>) {
    for child in &structure.children {
        if let Node::Structure(child_structure) = child {
            if child_structure.type_name == "Mapping" {
                result.push(child_structure);
                collect_nested_structures(child_structure, result);
            } else if child_structure.type_name == "Vec" {
                // Check if Vec contains structures
                for vec_child in &child_structure.children {
                    if let Node::Structure(vec_structure) = vec_child {
                        if vec_structure.type_name == "Mapping" {
                            result.push(vec_structure);
                            collect_nested_structures(vec_structure, result);
                        }
                    }
                }
            }
        }
    }
}

// ==================== Python Code Generation ====================

/// Map Rust types to Python types
fn rust_type_to_python(rust_type: &str) -> String {
    match rust_type {
        "i64" | "u64" => "int".to_string(),
        "f64" => "float".to_string(),
        "bool" => "bool".to_string(),
        "String" => "str".to_string(),
        "Option<String>" => "str | None".to_string(),
        other if other.starts_with("Vec<") => {
            // Extract inner type and convert
            let inner = &other[4..other.len()-1];
            format!("tuple[{}]", rust_type_to_python(inner))
        }
        _ => rust_type.to_string(), // Keep as-is for custom types
    }
}

/// Generate Python type annotation for a node
fn generate_python_type_annotation(node: &Node) -> String {
    match node {
        Node::Leaf(leaf) => rust_type_to_python(&leaf.type_name),
        Node::Structure(structure) => {
            match structure.type_name.as_str() {
                "Mapping" => to_pascal_case(&structure.name),
                "Vec" => {
                    if let Some(first_child) = structure.children.first() {
                        format!("tuple[{}]", generate_python_type_annotation(first_child))
                    } else {
                        "tuple".to_string()
                    }
                }
                _ => structure.type_name.clone(),
            }
        }
    }
}

/// Generate Python field for dataclass
fn generate_python_field(node: &Node) -> String {
    let field_name = to_snake_case(node.name());
    let type_annotation = generate_python_type_annotation(node);
    format!("    {}: {}", field_name, type_annotation)
}

/// Generate Python dataclass from Structure
fn generate_python_dataclass(structure: &Structure, frozen: bool) -> String {
    let class_name = to_pascal_case(&structure.name);
    let mut result = String::new();

    // Dataclass decorator
    if frozen {
        result.push_str(&format!("@dataclass(frozen=True)\n"));
    } else {
        result.push_str(&format!("@dataclass\n"));
    }

    // Class definition
    result.push_str(&format!("class {}:\n", class_name));

    // Fields
    if structure.children.is_empty() {
        result.push_str("    pass\n");
    } else {
        for child in &structure.children {
            result.push_str(&generate_python_field(child));
            result.push('\n');
        }
    }

    result
}

/// Generate Python code for entire tree
pub fn generate_python_code(tree: &Tree, frozen: bool) -> String {
    let mut result = String::new();

    // Header with imports
    result.push_str("# Auto-generated by Heracless (Rust-powered)\n");
    result.push_str("# DO NOT EDIT THIS FILE MANUALLY\n\n");
    result.push_str("from dataclasses import dataclass\n");
    result.push_str("from datetime import datetime, date\n");
    result.push_str("from pathlib import Path\n");
    result.push_str("from typing import Any\n\n");

    // Collect all structures
    let mut structures = Vec::new();
    for child in &tree.children {
        match child {
            Node::Structure(structure) if structure.type_name == "Mapping" => {
                structures.push(structure);
                collect_nested_structures(structure, &mut structures);
            }
            _ => {}
        }
    }

    // Remove duplicates
    let mut seen = HashSet::new();
    let mut unique_structures = Vec::new();
    for structure in structures.iter().rev() {
        let name = to_pascal_case(&structure.name);
        if !seen.contains(&name) {
            seen.insert(name);
            unique_structures.push(*structure);
        }
    }
    unique_structures.reverse();

    // Generate dataclass definitions (reversed for proper dependency order)
    for structure in unique_structures.iter().rev() {
        result.push_str(&generate_python_dataclass(structure, frozen));
        result.push('\n');
    }

    // Generate root Config class
    if frozen {
        result.push_str("@dataclass(frozen=True)\n");
    } else {
        result.push_str("@dataclass\n");
    }
    result.push_str("class Config:\n");

    if tree.children.is_empty() {
        result.push_str("    pass\n");
    } else {
        for child in &tree.children {
            result.push_str(&generate_python_field(child));
            result.push('\n');
        }
    }

    result.push_str("\n\ndef load_config(config_path: str) -> Config:\n");
    result.push_str("    ...\n");

    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::tree::{Leaf, Node, Structure, Tree};
    use serde_yaml::Value;

    #[test]
    fn test_generate_type_annotation() {
        let leaf = Node::Leaf(Leaf {
            name: "test".to_string(),
            type_name: "String".to_string(),
            value: Value::String("test".to_string()),
        });
        assert_eq!(generate_type_annotation(&leaf), "String");
    }

    #[test]
    fn test_generate_field() {
        let leaf = Node::Leaf(Leaf {
            name: "test_field".to_string(),
            type_name: "i64".to_string(),
            value: Value::Number(42.into()),
        });
        assert_eq!(generate_field(&leaf), "    pub test_field: i64,");
    }
}
